import {Injectable} from '@angular/core';import {EventTypes, OidcSecurityService, PublicEventsService} from 'angular-auth-oidc-client';import {Router} from '@angular/router';import {SubscriptionAwareComponent} from '../subscription-aware.component';import {Observable, Subject, filter, map} from 'rxjs';import {JwtPayload} from 'jwt-decode';import {AppRoutingConstants} from '../../shared/app-routing.constant';import {ApplicationRole} from '../../shared/n3tk-roles-name';interface UserData extends UserInfoData {  aud: string;  authorities: string[];  sid: string;  scope: string;  realm_access: {    roles: string[];  };  resource_access: {    account: {      roles: string[];    };  };}interface UserInfoData extends JwtPayload {  sub: string;  username: string;  preferred_username: string;  email: string;  email_verified: string;  name: string;  given_name: string;  family_name: string;}@Injectable({  providedIn: 'root'})export class ApplicationService extends SubscriptionAwareComponent {  static readonly N3TK_DEFAULT_ROLE = 'default-roles-n3tk';  static readonly N3TK_ROLE_PREFIX = 'n3tk.';  private readonly userDataSubject: Subject<UserData>;  private readonly userInfoSubject: Subject<UserInfoData>;  constructor(    private readonly oidcSecurityService: OidcSecurityService,    private readonly route: Router,    eventService: PublicEventsService  ) {    super();    this.userDataSubject = new Subject<UserData>();    this.userInfoSubject = new Subject<UserInfoData>();    this.registerSubscription(      eventService        .registerForEvents()        .pipe(filter(notification => notification.type === EventTypes.SilentRenewStarted || notification.type === EventTypes.NewAuthenticationResult))        .subscribe(notification => {          if (notification.type === EventTypes.SilentRenewStarted) {            // Don't show spinner when renewing token: refreshToken & getting sign in keys          } else {            // deactivate Spinner when receiving NewAuthenticationResult event          }        })    );  }  login() {    this.oidcSecurityService.authorize();  }  postLogin(): void {    this.registerSubscriptions([      this.oidcSecurityService.getPayloadFromAccessToken().subscribe((data: UserData) => {        this.userDataSubject.next(data);        if (!data?.realm_access?.roles?.includes(ApplicationService.N3TK_DEFAULT_ROLE)) {          // Core role is missing          this.navigateToForbidden();        }      }),      this.getUserRole().subscribe(roles => {        if (!roles) {          // No roles found          this.navigateToForbidden();        }      }),      this.oidcSecurityService.getUserData().subscribe(userInfo => {        this.userInfoSubject.next(userInfo);      })    ]);  }  navigateToForbidden(): void {    void this.route.navigate([AppRoutingConstants.FORBIDDEN]);  }  getUserRole(): Observable<ApplicationRole[]> {    return this.oidcSecurityService.getPayloadFromAccessToken().pipe(      map((data: UserData) =>        data.realm_access.roles          .filter(role => role.startsWith(ApplicationService.N3TK_ROLE_PREFIX))          .map(role => role as ApplicationRole)          .filter(role => !!role)      )    );  }  logout() {    this.oidcSecurityService.logoff().subscribe(() => this.postLogout());  }  private postLogout() {    sessionStorage.clear();  }}